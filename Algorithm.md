# 정렬
* 버블소트 - O(n^2)
``` 
서로 인접한 두 원소 비교하여 정렬하는 알고리즘
```
* 힙소트 - O(nlogn)
```주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최소값부터 하나씩 꺼내서 정렬하는 알고리즘

* 머지소트 - O(nlogn)
	주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘

* 퀵소트 - 일반적으로 O(nlogn) 최악 O(n^2)
	피봇을 설정하고 피봇보다 큰값과 작은값으로 분할하여 정렬

* 삽입정렬 - 일반적 O(n^2) 가장 빠른 경우 O(n)
	두번째 값부터 시작하여 그앞의 원소들과 비교하여 삽입할 위치를 찾아 삽입하는 정렬 알고리즘

* 퀵선택 정렬 - n개의 배열에서 k번째 큰 수 찾는 알고리즘   - O(N)
	퀵정렬을 한후에 피봇 인덱스와 K를 비교
	k == 피봇  -> 인덱스 값 리턴
	k > 피봇 -> 피봇 +1 부터 마지막 인덱스까지 다시 퀵소트
	k < 피봇 -> 첫 인덱스 부터 피봇 -1 인덱스 까지 퀵소트
	
# DP (Dynamic Programming)
	문제를 여러개의 하위 문제로 나누어 푼 다음, 그것을 결합하여 해결하는 방식
	동적프로그래밍에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어,
	답은 한번만 계산하고 결과를 재활용하는 메모이제이션 기법으로 속도를 향상 시킬 수 있다.

## DP 두가지 조건
	Overlapping Subproblem - 주어진 문제는 같은 부분 문제가 여러번 재사용 된다.
	Optimal Substructure - 새로운 부분 문제의 정답을 다른 부분 문제의 정답으로부터 구할 수 있다.

# 재귀 알고리즘
	함수 내부에서 함수가 자기 자신을 또 다시 호출하여 해결해 나가는 알고리즘
	중단할 조건이 반드시 필요 (없을시 무한루프)

# 허프만 코딩
	문자의 빈도를 이용해 압축하는 방법
	문자의 빈도수가 높을 수록 짧은 코드 부여
	접두부 코드와 최적 코드 사용한다.
## 접두부 코드 	
		문자에 부여된 코드가 다른 이진 코드의 접두부가 되지 않는 코드
## 최적 코드
		인코딩된 메세지의 길이가 가장 짧은 코드
