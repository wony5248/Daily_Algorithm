# C언어 포인터란
	포인터는 어떤 변수의 주소값을 저장하는 변수 입니다.
	선언은 *를 붙여서 선언하고
	주소값 얻기 위해선 &를 붙이면 된다.

# JAVA의 장점과 단점
* 장점
```
JVM 위에서 동작하기 때문에 운영체제에 독립적이다.
가비지 컬렉터가 메모리 관리해주기 때문에 편리하다.
```
* 단점
```
JVM위에서 동작하기 때문에 실행속도가 느리다.
다중 상속이나 타입에 엄격하는 등 제약이 많다.
```

# 오버라이딩과 오버로딩
* 오버라이딩
```
상위 클래스가 가지고 있는 메소드를 하위 클래스에서 재정의 하여 사용하는 기술
```
* 오버로딩
```
매개변수의 타입과 개수를 변경하면서 같은 이름의 메소드를 여러개 사용하는 기술
```
# 클래스, 객체, 인스턴스 개념
* 클래스 - 객체를 만들어내기 위한 설계도 혹은 틀
* 객체 - 설계도(클래스)를 기반으로 선언된 대상, 클래스의 인스턴스라고도 부름
* 인스턴스 - 객체에 메모리가 할당되어 실제로 활용되는 실체

# 싱글톤 패턴(Singleton Pattern) 구현 및 사용 이유 - 싱글톤 패턴은 단 하나의 인스턴스를 생성하여 사용하는 디자인 패턴이다.
	해당 인스턴스가 절대적으로 1개만 존재한다는 것을 보증하고 싶은 경우
	동일한 인스턴스를 자주 생성해 주어야 하는 경우
	싱글톤 패턴은 객체 지향 설계의 원칙에 적합하지 않으며, LifeCycle 제어가 힘들고, 멀티 스레드 환경에서 여러개 객체 생성되는 문제 발생 가능
	멀티스레드 환경에서는 static 앞에 synchronized키워드 붙여 동기화 작업 추가해야함(성능은 저하)

* 클래스나 인터페이스 끼리 상속할때는 extends
* 클래스에가 인터페이스 상속 받을때는 implements

# 추상 클래스와 인터페이스의 공통점과 차이
* 공통점
 ```
선언만 있고 구현 내용은 없는 클래스
인스턴스화가 불가능
추상클래스를 extends로 상속받은 자식들과 인터페이스를 implements하고 구현한 자식들만 객체를 생성 가능
자식 클래스가 무언가 반드시 구현하도록 위임해야할 때 사용
```
* 추상 클래스
```
상속 받아서 기능 확장시키는 것이 목표
단일 상속만이 가능
모든 접근 제어자 사용 가능
변수와 상수 선언 가능
추상 메소드와 일반 메소드 선언 가능
```
* 인터페이스 - 추상 클래스보다 한 단계 더 추상화된 클래스
```
구현하는 모든 클래스에 대해 특정한 메서드가 반드시 존재하도록 강제하는 역할
다중 상속 가능
public 접근 제어자만 사용 가능
상수만 선언 가능
추상 메소드만 선언 가능
```

# List, Set, Map 차이
* List
```
데이터 순차적으로 저장
데이터 중복 허용
데이터로 null 허용
```
* Set
```
순서없이 Key로만 데이터를 저장한다.
Key의 중복을 허용하지 않는다.
Key로 null 허용하지 않는다.
```
* Map
```
순서없이 key, value로 데이터 저장
value는 중복 허용 key는 중복 허용 X
key로 null 허용하지 않는다.
```

# Vector와 ArrayList 차이
* Vector
```
동기화를 지원한다.
속도가 느리지만 병렬 상황에서 안전하다
크기가 증가하는 경우, 2배 증가함
```
* ArrayList
```
동기화를 지원하지 않는다.
속도는 빠르지만 병렬 상황에서 안전하지 않다.
크기가 증가하는 경우, 1.5배 증가
```

# StringBuffer와 StringBuilder 차이
* StringBuffer
```
동기화를 지원
속도가 느리지만 병렬상황에서 안전
```
* StringBuilder
```
동기화를 지원하지 않는다.
속도는 빠르지만 병렬상황에서 안전하지 않다.
```

# synchronized
	synchronized 키워드는 여러 쓰레드가 하나의 자원을 이용하고자 할 때, 한 쓰레드가 해당 자원을 사용중인 경우, 데이터에 접근할 수 없도록 막는 키워드
	병렬 상황에서 자원의 접근을 안전하게 하지만, 자원 이용하지 않는 쓰레드는 락에의한 병목현상이 발생
* synchronized 메소드
```
한 시점에 하나의 쓰레드만이 해당 메소드 실행 가능
```
* synchronized 변수
```
한 시점에 하나의 쓰레드만이 해당 변수 참조 가능
```

# Java8
	함수형 프로그래밍을 위한 stream API와 Lambda, 함수형 인터페이스 등과 Null-safe한 작업을 위한 API 추가
	
* stream API 
	* 장점	
	```
	코드 간결하게 작성하여 가독성 증가
	병렬 스트림과 같은 기술 이용하여 처리속도 상향
	```
	* 단점
	```
	잘못 사용시 기존보다 성능 낮아짐
	코드들이 추상화 되어 있기에 실수 발생 가능성이 있다.
	```

# Lambda
	람다는 불필요한 코드를 줄이고 가독성 높이기 위한 익명 함수이다.
	함수의 이름과 반환타입 없이 선언가능하다.
	람다의 반환값은 함수형 인터페이스 이다.

# JVM의 메모리 구조
* Method Area
```
클래스 변수의 이름, 타입, 접근 제어자 등과 같은 클래스 관련 정보 저장
```
* Heap Area
```
new를 통해 생성된 객체와 배열의 인스턴스를 저장하는 공간
가비지 컬렉터를 통해 청소되는 영역
```
* Stack Area
```
메소드가 실행되면 스택 영역에 메소드에 대한 영역이 1개 생긴다.
지역변수, 매개변수, 리턴값 등이 저장된다.
```
* PC register
```
현재 쓰레드가 실행되는 부분의 주소와 명령을 저장한다.
```
* Native Method Stack
```
자바 외의 언어로 작성된 코드를 위한 메모리 영역
JNI를 통해 사용된다.
```
* JNI(Java Native Interface)
```
운영체제가 구현된언어(c, c++)로 운영체제의 고유기능을 만든다.
jvm과 java가 아닌 platform 의존적인 모든 native 언어로 구성된 라이브러리 사이에 정의된 인터페이스
```

# 가비지 컬렉터
	더이상 참조되지 않는 메모리인 가비지를 청소해주는 JVM의 실행 엔진의 한 요소
	new와 같은 연산에 의해 새롭게 생성된 객체들 중 더 이상 참조되지 않는 객체를 정리해 준다.
	Heap 영역 위주로 탐색

# 가비지 컬렉션
	일반적으로 메모리의 사용을 중단한 채로 진행이 되어야 한다.
	애플리케이션의 실행을 멈추는 stop-the-world를 먼저 실행 -> GC 실행하는 쓰레드 제외한 모든 쓰레드 작업 멈춘다.
	GC가 끝나면 다시 작업 재개
* GC는 Young 영역에 대한 Minor GC와 Old 영역에 대한 Major GC로 구분
	* Young 영역 
	```
	새롭게 생성된 객체들 위치, 대부분의 객체는 금방 접근 불가 상태가 되기에 Young영역에 생성되었다가 사라진다.
	1개의 Eden 영역 과 2개의 Survivor영역
	새로운 객체 생성
	GC가 Eden영역에 동작, 그중 살아남은 객체 Survivor0으로 이동
	반복작업시 survivor0 꽉참 -> survivor0 영역에 GC 동작 살아남은거 Survivor1로 이동 Survivor0 비움
	Survivor1에서도 살아 남은 객체는 Old로 이동
	```
	* Old 영역 
	```
	Young 영역에서 계속 사용되어 살아남은 객체가 복사되는 영역, Young영역보다 크게 할당 더 적은 GC 발생
	Old가 꽉차서 Survivor에서 Old로의 Promotion 불가시 Old에 가비지 컬렉션 실행
	```
	
# 가비지 컬렉션 알고리즘
* Serial GC - mark-sweep-comapct 알고리즘
```
Old영역에서 살아잇는 객체 식별(Mark)하고 살아있는 객체만을 남긴다.(Sweet) 
그 다음 객체들을 앞부분부터 채워 객체가 존재하는 부분과 존재하지 않는 부분으로 나눈다(Compaction)
```
* Parallel GC
```
기본적인 알고리즘은 Serial GC와 같지만 여러 쓰레드를 이용해 GC 처리
Parallel Old GC(Parallel Compacting GC)
Serial GC 의 sweep 알고리즘 대신 Summary를 사용
Summary 단계는 앞서 GC를 수행한 영역에 대해서 별도 살아있는 객체 식별하기에 sweep보다 복잡
```
* Concurrent Mark & Sweep GC(CMS) 
```
응답속도가 매우 중요할 때 사용
Initial Mark단계에서는 살아 있는 객체 찾는것으로 끝냄 - stop-the-world 시간 짧음
찾은 객체에서 참조하는 객체를 Concurrent(여러 쓰레드가 동시에) 따라가는 Concurrent Mark단계 수행
그 이후 stop-the-world 단계가 실행되고 Concurrent하게 동작
```
* G1 GC(Garbage First GC)
```
바둑판의 각 영역에 객체를 할당하고 GC를 실행한다.
Young 영역과 Old영역에 대한 개념을 사용하지 않고 객체를 할당
```
# GC 작동의 문제 진단법
	Survivor영역중 하나는 반드시 비어있는 상태로 남아 있어야 한다.
	두 Survior영역에 모두 데이터가 존재하거나, 두 영역 모두 사용량이 0이라면 정상상태가 아님
	GC에 대한 로그를 확인하여 옵션을 수정할지 코드를 수정할 지 정해야 함

# GC 시스템 중단 시간 줄이는 법
* 옵션 변경
```
young 영역과 old 영역의 힙 크기 높여 GC의 빈도 줄이는 것
Minor GC의 실행시간은 힙의 크기보다 GC에서 살아남은 객체의 수에 영향을 더 받음
객체의 할당과 promotion을 줄이는 것
```
* 설정 변경
```
애플리케이션 중단 후 GC를 병렬로 진행
애플리케이션과 GC 작업을 concurrent하게 진행
```
* 코드 변경
```
Collection 등을 활용할 때 사용할 객체의 크기 명시해주기
스트림을 바로 사용하기
불변 객체 사용하기
```
